
<!-- checks_doxygen_header.html -->

<!-- From Sample custom Doxygen header from my_doxygen_header.html  -->-

<!-- Copyright 2011 Pierre Talbot. -->

<!-- Distributed under the Boost Software License, Version 1.0. -->
<!-- (See accompanying file LICENSE_1_0.txt or copy at          -->
<!-- http://www.boost.org/LICENSE_1_0.txt)                      -->

<html> <!-- </html> is in footer. -->

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1"/>

  <!-- Add your title here ! -->
  <title>Boost.Checks Tue Aug 23 2011 09:36:53 Boost.Checks </title>

  <!-- Add your custom stylesheet here ! -->
  <link href="../checks_doxygen.css" rel="stylesheet" type="text/css"/>
  <!-- Note that this overrides any stylesheet specified in doxyfile setting HTML_STYLESHEET="mystylesheet.css" ! -->
  <link href="tabs.css" rel="stylesheet" type="text/css"/>
</head>

<!-- Add draft background here if, for example, not yet accepted or otherwise not finalised. -->
<body style="background-image: url(../../images/draft.png);">
</body>

<!-- You could also flag status by using a color? -->
<!--<body style="background-image: url(../../images/draft.png) ; color : darkblue"> -->

<!-- </body> is in footer. -->

<!-- Add your logo here or -->
<!-- Boost logo here if accepted after review, else some "Proposed for Boost" logo, for example the one below, or "proposed for Boost" ! -->
<table cellpadding="5" width="100%">
  <tbody>
    <tr>
      <td valign="top"><img alt="Proposed for Boost." src="../../images/proposed_for_boost.png" height="80" width="250"/></td>
    </tr>
  </tbody>
</table>
<p>
  <br/>  <!-- Some space below logo, if needed. -->
</p>

<!-- Generated by Doxygen 1.7.5.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="namespaceboost.html">boost</a>      </li>
      <li class="navelem"><a class="el" href="namespaceboost_1_1checks.html">checks</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">boost::checks Namespace Reference</div>  </div>
</div>
<div class="contents">
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1amex__algorithm.html">amex_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with the Luhn algorithm but filter following the amex pattern.  <a href="structboost_1_1checks_1_1amex__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1basic__check__algorithm.html">basic_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The main check algorithm class that provides every static functions that can be overloaded.<br/>
 Most of the functions must be re-implemented to have the desired behavior.  <a href="structboost_1_1checks_1_1basic__check__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1isbn13__algorithm.html">isbn13_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with a basic modulus 10 but using a custom filter for the ISBN-13 prefix.  <a href="structboost_1_1checks_1_1isbn13__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1rightmost.html">rightmost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class that provides methods to run through a sequence from right to left.  <a href="structboost_1_1checks_1_1rightmost.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1leftmost.html">leftmost</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Policy class that provides methods to run through a sequence from left to right.  <a href="structboost_1_1checks_1_1leftmost.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1strict__size__contract.html">strict_size_contract</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a contract class used to verify that a sequence have the expected size.  <a href="structboost_1_1checks_1_1strict__size__contract.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1no__null__size__contract.html">no_null_size_contract</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a contract class used to verify that a sequence have not a size of zero.  <a href="structboost_1_1checks_1_1no__null__size__contract.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1luhn__algorithm.html">luhn_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with the Luhn algorithm.  <a href="structboost_1_1checks_1_1luhn__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1mastercard__algorithm.html">mastercard_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with the Luhn algorithm but filter following the Mastercard pattern.  <a href="structboost_1_1checks_1_1mastercard__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">modulus10_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with a basic modulus 10.  <a href="structboost_1_1checks_1_1modulus10__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1modulus11__algorithm.html">modulus11_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with a basic modulus 11.  <a href="structboost_1_1checks_1_1modulus11__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1modulus97__algorithm.html">modulus97_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with a basic modulus 97.  <a href="structboost_1_1checks_1_1modulus97__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1make__mod97__weight.html">make_mod97_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is used to pre-computed the weight of the mod97-10 algorithm (a = 1; a = a * 10 % 97 ;).  <a href="structboost_1_1checks_1_1make__mod97__weight.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1make__mod97__weight_3_0168_01_4.html">make_mod97_weight&lt; 68 &gt;</a></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classboost_1_1checks_1_1translation__exception.html">translation_exception</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides support for translation failure. For example, sequence value into integer, or integer into check digit type.  <a href="classboost_1_1checks_1_1translation__exception.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1verhoeff__algorithm.html">verhoeff_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with the Verhoeff algorithm.  <a href="structboost_1_1checks_1_1verhoeff__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1visa__algorithm.html">visa_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class can be used to compute or validate checksum with the Luhn algorithm but filter following the Visa pattern.  <a href="structboost_1_1checks_1_1visa__algorithm.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1weight.html">weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The weight metafunction encapsulate 0 to BOOST_CHECK_LIMIT_WEIGHTS weights.  <a href="structboost_1_1checks_1_1weight.html#details">More...</a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structboost_1_1checks_1_1weighted__sum__algorithm.html">weighted_sum_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This class permit to add to the current checksum the weight multiply by the current value.  <a href="structboost_1_1checks_1_1weighted__sum__algorithm.html#details">More...</a><br/></td></tr>
<tr><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1amex__algorithm.html">amex_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ad6e89cce2497202c43286e24ee800903">amex_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Amex algorithm for validating a check digit.  <a href="#ad6e89cce2497202c43286e24ee800903"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1amex__algorithm.html">amex_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a8e61204056ca87bdb92f246c12774b5d">amex_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Amex algorithm for computing a check digit.  <a href="#a8e61204056ca87bdb92f246c12774b5d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">ean_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the weight used by EAN system.  <a href="#a9954b4088442885ef6e2576de09a447a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">ean_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the running sense to check an EAN.  <a href="#a5777fac9f48a6435fb586c59c3cfe85b"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">ean_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">ean_sense</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a7ade1a7caf15a4e84fe883128d230415">ean_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the EAN algorithm for validating a check digit.  <a href="#a7ade1a7caf15a4e84fe883128d230415"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">ean_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">ean_sense</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a155a87965d77be3e8ca147deca9e8642">ean_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the EAN algorithm for computing a check digit.  <a href="#a155a87965d77be3e8ca147deca9e8642"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1isbn13__algorithm.html">boost::checks::isbn13_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a268063a04f4922a2fa58daf19baa616c">isbn13_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the ISBN-13 algorithm for validating a check digit.  <a href="#a268063a04f4922a2fa58daf19baa616c"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1isbn13__algorithm.html">boost::checks::isbn13_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#aa04af64ebe32659934424590adb037ed">isbn13_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the ISBN-13 algorithm for computing a check digit.  <a href="#aa04af64ebe32659934424590adb037ed"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt; 1, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a07ef187e34f49f346f0af0378d5acc50">luhn_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the weight used by the Luhn algorithm.  <a href="#a07ef187e34f49f346f0af0378d5acc50"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a5a32b294c38ffb4402a883b6438bd285">luhn_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the running sense to check an Luhn number.  <a href="#a5a32b294c38ffb4402a883b6438bd285"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1luhn__algorithm.html">luhn_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a19d649f8bb40c5ecd4407637ff581e75">luhn_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Luhn algorithm for validating a check digit.  <a href="#a19d649f8bb40c5ecd4407637ff581e75"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1luhn__algorithm.html">luhn_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ac2e4fa7c035bea78225af042d690b0d7">luhn_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Luhn algorithm for computing a check digit.  <a href="#ac2e4fa7c035bea78225af042d690b0d7"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1mastercard__algorithm.html">mastercard_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a216597b28715b6f774d51ba2ffa9e38d">mastercard_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Mastercard algorithm for validating a check digit.  <a href="#a216597b28715b6f774d51ba2ffa9e38d"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1mastercard__algorithm.html">mastercard_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a8da35e1a8a76d25048b5258df10ecff5">mastercard_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Mastercard algorithm for computing a check digit.  <a href="#a8da35e1a8a76d25048b5258df10ecff5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt; 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">mod11_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The most common weight pattern used with a modulus 11 algorithm.  <a href="#a64fa88448138043e7005fd6a8ab96ca0"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">mod11_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The most common iteration sense used with a modulus 11 algorithm.  <a href="#a301a34d78937488786d783d37703e61f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1modulus11__algorithm.html">modulus11_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">mod11_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">mod11_sense</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a3e7a6811ebe47566037d3df5b984b654">mod11_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the most common modulus 11 algorithm for validating a check digit.  <a href="#a3e7a6811ebe47566037d3df5b984b654"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1modulus11__algorithm.html">modulus11_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">mod11_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">mod11_sense</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a335686e6e27a2f273da403df3e8a7ce2">mod11_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the most common modulus 11 algorithm for computing a check digit.  <a href="#a335686e6e27a2f273da403df3e8a7ce2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1make__mod97__weight.html">make_mod97_weight</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a6e393a7c0f86be5625ed099b1f19a7a2">initial_mod97_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the initial weight for the mod97-10 weights serie.  <a href="#a6e393a7c0f86be5625ed099b1f19a7a2"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a><br class="typebreak"/>
&lt; BOOST_PP_ENUM(96, <br class="typebreak"/>
MOD97_weight_maker,~) &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">mod97_10_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is weight of the mod97-10 algorithm.  <a href="#a8ecfb8f9e67b6348df22bdb2934e10d6"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">mod97_10_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">The iteration sense of the sequence. From right to left.  <a href="#a877b2a498e290daf7bd3894298c162ae"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1modulus97__algorithm.html">modulus97_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">mod97_10_weight</a>, <br class="typebreak"/>
<a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">mod97_10_sense</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a381ae47bc53437d1f84e8a252964a8cb">mod97_10_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the modulus 97-10 algorithm for validating a check digit.  <a href="#a381ae47bc53437d1f84e8a252964a8cb"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1modulus97__algorithm.html">modulus97_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">mod97_10_weight</a>, <br class="typebreak"/>
<a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">mod97_10_sense</a>, 2 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#aca43234abcde3ab58a2092a3283829a5">mod97_10_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the modulus 97-10 algorithm for computing a check digit.  <a href="#aca43234abcde3ab58a2092a3283829a5"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt; 1, 3 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">upc_weight</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the weight used by UPC system.  <a href="#acbf981f5856e57b68e8860594f9aa572"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">upc_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the running sense to check an UPC.  <a href="#af677c97bdddd63cbe273974672c03616"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">upc_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">upc_sense</a>, 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a6ab9ef49508b3081845481fdfe7bb78f">upc_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the UPC algorithm for validating a check digit.  <a href="#a6ab9ef49508b3081845481fdfe7bb78f"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <br class="typebreak"/>
<a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a><br class="typebreak"/>
&lt; <a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">upc_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">upc_sense</a>, 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a4a8f9d39418287c4004d9ed79e4b1240">upc_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the UPC algorithm for computing a check digit.  <a href="#a4a8f9d39418287c4004d9ed79e4b1240"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a752731034c77974a50e886866ca5895a">verhoeff_iteration_sense</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the sense of the Verhoeff sequence iteration.  <a href="#a752731034c77974a50e886866ca5895a"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1verhoeff__algorithm.html">verhoeff_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a5ce2d0db03cfe90a961779538d897a22">verhoeff_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Verhoeff algorithm for validating a check digit.  <a href="#a5ce2d0db03cfe90a961779538d897a22"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1verhoeff__algorithm.html">verhoeff_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a93cfc6f3a20335c421e20f92d3c821c8">verhoeff_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Verhoeff algorithm for computing a check digit.  <a href="#a93cfc6f3a20335c421e20f92d3c821c8"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1visa__algorithm.html">visa_algorithm</a>&lt; 0 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a6d5c430a2bceeedf1002d92a98aa4c43">visa_check_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Visa algorithm for validating a check digit.  <a href="#a6d5c430a2bceeedf1002d92a98aa4c43"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="structboost_1_1checks_1_1visa__algorithm.html">visa_algorithm</a>&lt; 1 &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a323a27cc40681492362fb3c0893979cb">visa_compute_algorithm</a></td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">This is the type of the Visa algorithm for computing a check digit.  <a href="#a323a27cc40681492362fb3c0893979cb"></a><br/></td></tr>
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a2aff225983f36758feaba34662173b53">check_amex</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the amex_check_algorithm type.  <a href="#a2aff225983f36758feaba34662173b53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::amex_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a04b6c190de7e9bb7a99841a8ad996459">compute_amex</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the amex_compute_algorithm type.  <a href="#a04b6c190de7e9bb7a99841a8ad996459"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , typename size_contract , typename iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a47d3a9835bc33566a01ca5614a13f1fe">compute_checksum</a> (iterator seq_begin, iterator seq_end)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Run through a sequence and calculate the checksum with the algorithm policy class.  <a href="#a47d3a9835bc33566a01ca5614a13f1fe"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , typename size_contract , typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">int&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a635c57c7b253fcadc1dfa5415d7647b1">compute_checksum</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Create iterators according to the algorithm::iterator policy. And call the iterator overload version of compute_checksum.  <a href="#a635c57c7b253fcadc1dfa5415d7647b1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a3e9f9bfde34262ad3f4e69ddf2e1bbd4">check_sequence</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to algorithm.  <a href="#a3e9f9bfde34262ad3f4e69ddf2e1bbd4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a574b80a0aafa204b1079de298dad8ea5">check_sequence</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to algorithm.  <a href="#a574b80a0aafa204b1079de298dad8ea5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#af2694703fb484efc186146542e4a7c53">compute_checkdigit</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to algorithm.  <a href="#af2694703fb484efc186146542e4a7c53"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a58d8bcbe9cc7d264f4a2b09d49717a56">compute_checkdigit</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to algorithm.  <a href="#a58d8bcbe9cc7d264f4a2b09d49717a56"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , typename check_range , typename checkdigit_iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">checkdigit_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#adbf0f4f0f946d7c47fddd7553d9cd065">compute_multicheckdigit</a> (const check_range &amp;check_seq, checkdigit_iterator checkdigits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the checkdigits of a sequence according to algorithm.  <a href="#adbf0f4f0f946d7c47fddd7553d9cd065"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename algorithm , size_t size_expected, typename check_range , typename checkdigit_iterator &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">checkdigit_iterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a5b6bdc6137cc4bc9b494138fa8b6127c">compute_multicheckdigit</a> (const check_range &amp;check_seq, checkdigit_iterator checkdigits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the checkdigits of a sequence according to algorithm.  <a href="#a5b6bdc6137cc4bc9b494138fa8b6127c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a36a3ea230792e9f9ba0c02ce1c46354c">check_luhn</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the luhn_check_algorithm type.  <a href="#a36a3ea230792e9f9ba0c02ce1c46354c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a2651a01fc5a7a3eec7381f18fcb04295">check_luhn</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the luhn_check_algorithm type.  <a href="#a2651a01fc5a7a3eec7381f18fcb04295"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::luhn_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a8f86db1b7d82751de71288456d4edf0a">compute_luhn</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the luhn_compute_algorithm type.  <a href="#a8f86db1b7d82751de71288456d4edf0a"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::luhn_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a72f611fe14c840774de011e0271eb4b0">compute_luhn</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the luhn_compute_algorithm type.  <a href="#a72f611fe14c840774de011e0271eb4b0"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#abe6ccc42ec484aac046ea80bfaad4ae4">check_verhoeff</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the verhoeff_check_algorithm type.  <a href="#abe6ccc42ec484aac046ea80bfaad4ae4"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a86e8991bc68fab9958a902b140bd05c6">check_verhoeff</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the verhoeff_check_algorithm type.  <a href="#a86e8991bc68fab9958a902b140bd05c6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::verhoeff_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a069b69920cc6182e4bd0f1414cdc7747">compute_verhoeff</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the verhoeff_compute_algorithm type.  <a href="#a069b69920cc6182e4bd0f1414cdc7747"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::verhoeff_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a4bcb041b2939d1b52d223b9372b24536">compute_verhoeff</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the verhoeff_compute_algorithm type.  <a href="#a4bcb041b2939d1b52d223b9372b24536"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#acb7e8e0940822a9cb6836251c064e03f">check_modulus11</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mod11_check_algorithm type.  <a href="#acb7e8e0940822a9cb6836251c064e03f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a2d76774a0b153e9046cd18823cc12dd6">check_modulus11</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mod11_check_algorithm type.  <a href="#a2d76774a0b153e9046cd18823cc12dd6"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::mod11_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a65a3b463188c57b0991eeb513e36817d">compute_modulus11</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the mod11_compute_algorithm type.  <a href="#a65a3b463188c57b0991eeb513e36817d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::mod11_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a9cb1939fed27705a86a2e609c49e35e5">compute_modulus11</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the mod11_compute_algorithm type.  <a href="#a9cb1939fed27705a86a2e609c49e35e5"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#afbc1a04be2d50c0caeb8f15237930513">check_mod97_10</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mod97_10_check_algorithm type.  <a href="#afbc1a04be2d50c0caeb8f15237930513"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#aa32d98f0c9606a1d46786a57151c81ab">check_mod97_10</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mod97_10_check_algorithm type.  <a href="#aa32d98f0c9606a1d46786a57151c81ab"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;size_t size_expected, typename check_range , typename checkdigits_iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">checkdigits_iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#aa4c7db694c89fb4ba0a2b288776c66f3">compute_mod97_10</a> (const check_range &amp;check_seq, checkdigits_iter mod97_checkdigits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digits of a sequence according to the mod97_10_compute_algorithm type.  <a href="#aa4c7db694c89fb4ba0a2b288776c66f3"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range , typename checkdigits_iter &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">checkdigits_iter&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a8f1e84d2acc21b23ebe972ca73a879b7">compute_mod97_10</a> (const check_range &amp;check_seq, checkdigits_iter mod97_checkdigits)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digits of a sequence according to the mod97_10_compute_algorithm type.  <a href="#a8f1e84d2acc21b23ebe972ca73a879b7"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a99f1f79f65b14f9f2c68477c69ab7420">check_ean13</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the ean_check_algorithm type.  <a href="#a99f1f79f65b14f9f2c68477c69ab7420"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::ean_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ac08dd90c2f9518ad9f9addb3863db98e">compute_ean13</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the ean_compute_algorithm type.  <a href="#ac08dd90c2f9518ad9f9addb3863db98e"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a1d5df84c16aa8c879214bf8f6a6993ea">check_ean8</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the ean_check_algorithm type.  <a href="#a1d5df84c16aa8c879214bf8f6a6993ea"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::ean_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#adb63ff3a11463aba48f55b5d96dfada1">compute_ean8</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the ean_compute_algorithm type.  <a href="#adb63ff3a11463aba48f55b5d96dfada1"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#af52b5d0c188f321561b69f312c93b336">check_isbn10</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mod11_check_algorithm type.  <a href="#af52b5d0c188f321561b69f312c93b336"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::mod11_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a41519cb136ca0786262764baa7b4622f">compute_isbn10</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the mod11_compute_algorithm type.  <a href="#a41519cb136ca0786262764baa7b4622f"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a787f7cd04f5561dcdadff392c5af0bee">check_isbn13</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the isbn13_check_algorithm type.  <a href="#a787f7cd04f5561dcdadff392c5af0bee"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::isbn13_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a5dd55ec9238d3d11527546f34d5ce2db">compute_isbn13</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the isbn13_compute_algorithm type.  <a href="#a5dd55ec9238d3d11527546f34d5ce2db"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a944d9977c2db906b76346bc76928f06d">check_upca</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the upc_check_algorithm type.  <a href="#a944d9977c2db906b76346bc76928f06d"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::upc_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ae494e5fd020da1bacf88547eda843b81">compute_upca</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the upc_compute_algorithm type.  <a href="#ae494e5fd020da1bacf88547eda843b81"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ab59d983a0e6f7df034570cdf7e14bdcb">check_visa</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the visa_check_algorithm type.  <a href="#ab59d983a0e6f7df034570cdf7e14bdcb"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::visa_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a4770ebdffc040e9cc9cb1fb6f1d75457">compute_visa</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the visa_compute_algorithm type.  <a href="#a4770ebdffc040e9cc9cb1fb6f1d75457"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#ae9e7b0798732cefb3c6d51a4cc68d09c">check_mastercard</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Validate a sequence according to the mastercard_check_algorithm type.  <a href="#ae9e7b0798732cefb3c6d51a4cc68d09c"></a><br/></td></tr>
<tr><td class="memTemplParams" colspan="2">template&lt;typename check_range &gt; </td></tr>
<tr><td class="memTemplItemLeft" align="right" valign="top">boost::checks::mastercard_compute_algorithm::checkdigit<br class="typebreak"/>
&lt; check_range &gt;::type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespaceboost_1_1checks.html#a0f8b86d5edf6cc569f494bb890c83dcc">compute_mastercard</a> (const check_range &amp;check_seq)</td></tr>
<tr><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate the check digit of a sequence according to the mastercard_compute_algorithm type.  <a href="#a0f8b86d5edf6cc569f494bb890c83dcc"></a><br/></td></tr>
</table>
<hr/><h2>Typedef Documentation</h2>
<a class="anchor" id="ad6e89cce2497202c43286e24ee800903"></a><!-- doxytag: member="boost::checks::amex_check_algorithm" ref="ad6e89cce2497202c43286e24ee800903" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1amex__algorithm.html">amex_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#ad6e89cce2497202c43286e24ee800903">boost::checks::amex_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Amex algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="amex_8hpp_source.html#l00065">65</a> of file <a class="el" href="amex_8hpp_source.html">amex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8e61204056ca87bdb92f246c12774b5d"></a><!-- doxytag: member="boost::checks::amex_compute_algorithm" ref="a8e61204056ca87bdb92f246c12774b5d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1amex__algorithm.html">amex_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#a8e61204056ca87bdb92f246c12774b5d">boost::checks::amex_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Amex algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="amex_8hpp_source.html#l00069">69</a> of file <a class="el" href="amex_8hpp_source.html">amex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a7ade1a7caf15a4e84fe883128d230415"></a><!-- doxytag: member="boost::checks::ean_check_algorithm" ref="a7ade1a7caf15a4e84fe883128d230415" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">ean_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">ean_sense</a>, 0&gt; <a class="el" href="namespaceboost_1_1checks.html#a7ade1a7caf15a4e84fe883128d230415">boost::checks::ean_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the EAN algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00056">56</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a155a87965d77be3e8ca147deca9e8642"></a><!-- doxytag: member="boost::checks::ean_compute_algorithm" ref="a155a87965d77be3e8ca147deca9e8642" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">ean_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">ean_sense</a>, 1&gt; <a class="el" href="namespaceboost_1_1checks.html#a155a87965d77be3e8ca147deca9e8642">boost::checks::ean_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the EAN algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00060">60</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5777fac9f48a6435fb586c59c3cfe85b"></a><!-- doxytag: member="boost::checks::ean_sense" ref="a5777fac9f48a6435fb586c59c3cfe85b" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#a5777fac9f48a6435fb586c59c3cfe85b">boost::checks::ean_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the running sense to check an EAN. </p>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00051">51</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9954b4088442885ef6e2576de09a447a"></a><!-- doxytag: member="boost::checks::ean_weight" ref="a9954b4088442885ef6e2576de09a447a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt;1,3&gt; <a class="el" href="namespaceboost_1_1checks.html#a9954b4088442885ef6e2576de09a447a">boost::checks::ean_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the weight used by EAN system. </p>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00047">47</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6e393a7c0f86be5625ed099b1f19a7a2"></a><!-- doxytag: member="boost::checks::initial_mod97_weight" ref="a6e393a7c0f86be5625ed099b1f19a7a2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1make__mod97__weight.html">make_mod97_weight</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#a6e393a7c0f86be5625ed099b1f19a7a2">boost::checks::initial_mod97_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the initial weight for the mod97-10 weights serie. </p>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00108">108</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a268063a04f4922a2fa58daf19baa616c"></a><!-- doxytag: member="boost::checks::isbn13_check_algorithm" ref="a268063a04f4922a2fa58daf19baa616c" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1isbn13__algorithm.html">boost::checks::isbn13_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#a268063a04f4922a2fa58daf19baa616c">boost::checks::isbn13_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the ISBN-13 algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00070">70</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa04af64ebe32659934424590adb037ed"></a><!-- doxytag: member="boost::checks::isbn13_compute_algorithm" ref="aa04af64ebe32659934424590adb037ed" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1isbn13__algorithm.html">boost::checks::isbn13_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#aa04af64ebe32659934424590adb037ed">boost::checks::isbn13_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the ISBN-13 algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00074">74</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a19d649f8bb40c5ecd4407637ff581e75"></a><!-- doxytag: member="boost::checks::luhn_check_algorithm" ref="a19d649f8bb40c5ecd4407637ff581e75" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1luhn__algorithm.html">luhn_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#a19d649f8bb40c5ecd4407637ff581e75">boost::checks::luhn_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Luhn algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00064">64</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac2e4fa7c035bea78225af042d690b0d7"></a><!-- doxytag: member="boost::checks::luhn_compute_algorithm" ref="ac2e4fa7c035bea78225af042d690b0d7" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1luhn__algorithm.html">luhn_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#ac2e4fa7c035bea78225af042d690b0d7">boost::checks::luhn_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Luhn algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00068">68</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5a32b294c38ffb4402a883b6438bd285"></a><!-- doxytag: member="boost::checks::luhn_sense" ref="a5a32b294c38ffb4402a883b6438bd285" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#a5a32b294c38ffb4402a883b6438bd285">boost::checks::luhn_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the running sense to check an Luhn number. </p>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00032">32</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a07ef187e34f49f346f0af0378d5acc50"></a><!-- doxytag: member="boost::checks::luhn_weight" ref="a07ef187e34f49f346f0af0378d5acc50" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt;1,2&gt; <a class="el" href="namespaceboost_1_1checks.html#a07ef187e34f49f346f0af0378d5acc50">boost::checks::luhn_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the weight used by the Luhn algorithm. </p>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00027">27</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a216597b28715b6f774d51ba2ffa9e38d"></a><!-- doxytag: member="boost::checks::mastercard_check_algorithm" ref="a216597b28715b6f774d51ba2ffa9e38d" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1mastercard__algorithm.html">mastercard_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#a216597b28715b6f774d51ba2ffa9e38d">boost::checks::mastercard_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Mastercard algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="mastercard_8hpp_source.html#l00065">65</a> of file <a class="el" href="mastercard_8hpp_source.html">mastercard.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8da35e1a8a76d25048b5258df10ecff5"></a><!-- doxytag: member="boost::checks::mastercard_compute_algorithm" ref="a8da35e1a8a76d25048b5258df10ecff5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1mastercard__algorithm.html">mastercard_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#a8da35e1a8a76d25048b5258df10ecff5">boost::checks::mastercard_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Mastercard algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="mastercard_8hpp_source.html#l00069">69</a> of file <a class="el" href="mastercard_8hpp_source.html">mastercard.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e7a6811ebe47566037d3df5b984b654"></a><!-- doxytag: member="boost::checks::mod11_check_algorithm" ref="a3e7a6811ebe47566037d3df5b984b654" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus11__algorithm.html">modulus11_algorithm</a>&lt;<a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">mod11_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">mod11_sense</a>, 0&gt; <a class="el" href="namespaceboost_1_1checks.html#a3e7a6811ebe47566037d3df5b984b654">boost::checks::mod11_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the most common modulus 11 algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00136">136</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a335686e6e27a2f273da403df3e8a7ce2"></a><!-- doxytag: member="boost::checks::mod11_compute_algorithm" ref="a335686e6e27a2f273da403df3e8a7ce2" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus11__algorithm.html">modulus11_algorithm</a>&lt;<a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">mod11_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">mod11_sense</a>, 1&gt; <a class="el" href="namespaceboost_1_1checks.html#a335686e6e27a2f273da403df3e8a7ce2">boost::checks::mod11_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the most common modulus 11 algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00140">140</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a301a34d78937488786d783d37703e61f"></a><!-- doxytag: member="boost::checks::mod11_sense" ref="a301a34d78937488786d783d37703e61f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#a301a34d78937488786d783d37703e61f">boost::checks::mod11_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The most common iteration sense used with a modulus 11 algorithm. </p>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00131">131</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a64fa88448138043e7005fd6a8ab96ca0"></a><!-- doxytag: member="boost::checks::mod11_weight" ref="a64fa88448138043e7005fd6a8ab96ca0" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt;1,2,3,4,5,6,7,8,9,10&gt; <a class="el" href="namespaceboost_1_1checks.html#a64fa88448138043e7005fd6a8ab96ca0">boost::checks::mod11_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The most common weight pattern used with a modulus 11 algorithm. </p>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00127">127</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a381ae47bc53437d1f84e8a252964a8cb"></a><!-- doxytag: member="boost::checks::mod97_10_check_algorithm" ref="a381ae47bc53437d1f84e8a252964a8cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus97__algorithm.html">modulus97_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">mod97_10_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">mod97_10_sense</a>, 0 &gt; <a class="el" href="namespaceboost_1_1checks.html#a381ae47bc53437d1f84e8a252964a8cb">boost::checks::mod97_10_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the modulus 97-10 algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00134">134</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aca43234abcde3ab58a2092a3283829a5"></a><!-- doxytag: member="boost::checks::mod97_10_compute_algorithm" ref="aca43234abcde3ab58a2092a3283829a5" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus97__algorithm.html">modulus97_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">mod97_10_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">mod97_10_sense</a>, 2 &gt; <a class="el" href="namespaceboost_1_1checks.html#aca43234abcde3ab58a2092a3283829a5">boost::checks::mod97_10_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the modulus 97-10 algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00138">138</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a877b2a498e290daf7bd3894298c162ae"></a><!-- doxytag: member="boost::checks::mod97_10_sense" ref="a877b2a498e290daf7bd3894298c162ae" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#a877b2a498e290daf7bd3894298c162ae">boost::checks::mod97_10_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>The iteration sense of the sequence. From right to left. </p>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00129">129</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8ecfb8f9e67b6348df22bdb2934e10d6"></a><!-- doxytag: member="boost::checks::mod97_10_weight" ref="a8ecfb8f9e67b6348df22bdb2934e10d6" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt; BOOST_PP_ENUM(96, MOD97_weight_maker, ~) &gt; <a class="el" href="namespaceboost_1_1checks.html#a8ecfb8f9e67b6348df22bdb2934e10d6">boost::checks::mod97_10_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is weight of the mod97-10 algorithm. </p>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00124">124</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6ab9ef49508b3081845481fdfe7bb78f"></a><!-- doxytag: member="boost::checks::upc_check_algorithm" ref="a6ab9ef49508b3081845481fdfe7bb78f" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">upc_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">upc_sense</a>, 0&gt; <a class="el" href="namespaceboost_1_1checks.html#a6ab9ef49508b3081845481fdfe7bb78f">boost::checks::upc_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the UPC algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00048">48</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4a8f9d39418287c4004d9ed79e4b1240"></a><!-- doxytag: member="boost::checks::upc_compute_algorithm" ref="a4a8f9d39418287c4004d9ed79e4b1240" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1modulus10__algorithm.html">boost::checks::modulus10_algorithm</a>&lt; <a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">upc_weight</a>, <a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">upc_sense</a>, 1&gt; <a class="el" href="namespaceboost_1_1checks.html#a4a8f9d39418287c4004d9ed79e4b1240">boost::checks::upc_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the UPC algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00052">52</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af677c97bdddd63cbe273974672c03616"></a><!-- doxytag: member="boost::checks::upc_sense" ref="af677c97bdddd63cbe273974672c03616" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#af677c97bdddd63cbe273974672c03616">boost::checks::upc_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the running sense to check an UPC. </p>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00043">43</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acbf981f5856e57b68e8860594f9aa572"></a><!-- doxytag: member="boost::checks::upc_weight" ref="acbf981f5856e57b68e8860594f9aa572" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1weight.html">boost::checks::weight</a>&lt;1,3&gt; <a class="el" href="namespaceboost_1_1checks.html#acbf981f5856e57b68e8860594f9aa572">boost::checks::upc_weight</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the weight used by UPC system. </p>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00039">39</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5ce2d0db03cfe90a961779538d897a22"></a><!-- doxytag: member="boost::checks::verhoeff_check_algorithm" ref="a5ce2d0db03cfe90a961779538d897a22" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1verhoeff__algorithm.html">verhoeff_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#a5ce2d0db03cfe90a961779538d897a22">boost::checks::verhoeff_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Verhoeff algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00125">125</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a93cfc6f3a20335c421e20f92d3c821c8"></a><!-- doxytag: member="boost::checks::verhoeff_compute_algorithm" ref="a93cfc6f3a20335c421e20f92d3c821c8" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1verhoeff__algorithm.html">verhoeff_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#a93cfc6f3a20335c421e20f92d3c821c8">boost::checks::verhoeff_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Verhoeff algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00129">129</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a752731034c77974a50e886866ca5895a"></a><!-- doxytag: member="boost::checks::verhoeff_iteration_sense" ref="a752731034c77974a50e886866ca5895a" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1rightmost.html">boost::checks::rightmost</a> <a class="el" href="namespaceboost_1_1checks.html#a752731034c77974a50e886866ca5895a">boost::checks::verhoeff_iteration_sense</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the sense of the Verhoeff sequence iteration. </p>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00032">32</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d5c430a2bceeedf1002d92a98aa4c43"></a><!-- doxytag: member="boost::checks::visa_check_algorithm" ref="a6d5c430a2bceeedf1002d92a98aa4c43" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1visa__algorithm.html">visa_algorithm</a>&lt;0&gt; <a class="el" href="namespaceboost_1_1checks.html#a6d5c430a2bceeedf1002d92a98aa4c43">boost::checks::visa_check_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Visa algorithm for validating a check digit. </p>

<p>Definition at line <a class="el" href="visa_8hpp_source.html#l00063">63</a> of file <a class="el" href="visa_8hpp_source.html">visa.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a323a27cc40681492362fb3c0893979cb"></a><!-- doxytag: member="boost::checks::visa_compute_algorithm" ref="a323a27cc40681492362fb3c0893979cb" args="" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="structboost_1_1checks_1_1visa__algorithm.html">visa_algorithm</a>&lt;1&gt; <a class="el" href="namespaceboost_1_1checks.html#a323a27cc40681492362fb3c0893979cb">boost::checks::visa_compute_algorithm</a></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>This is the type of the Visa algorithm for computing a check digit. </p>

<p>Definition at line <a class="el" href="visa_8hpp_source.html#l00067">67</a> of file <a class="el" href="visa_8hpp_source.html">visa.hpp</a>.</p>

</div>
</div>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="a2aff225983f36758feaba34662173b53"></a><!-- doxytag: member="boost::checks::check_amex" ref="a2aff225983f36758feaba34662173b53" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_amex </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the amex_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly AMEX_SIZE digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the two first digits (from the leftmost) don't match the amex pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="amex_8hpp_source.html#l00085">85</a> of file <a class="el" href="amex_8hpp_source.html">amex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a99f1f79f65b14f9f2c68477c69ab7420"></a><!-- doxytag: member="boost::checks::check_ean13" ref="a99f1f79f65b14f9f2c68477c69ab7420" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_ean13 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the ean_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN13_SIZE digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00075">75</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a1d5df84c16aa8c879214bf8f6a6993ea"></a><!-- doxytag: member="boost::checks::check_ean8" ref="a1d5df84c16aa8c879214bf8f6a6993ea" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_ean8 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the ean_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN8_SIZE digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00112">112</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af52b5d0c188f321561b69f312c93b336"></a><!-- doxytag: member="boost::checks::check_isbn10" ref="af52b5d0c188f321561b69f312c93b336" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_isbn10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mod11_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly ISBN10_SIZE digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00126">126</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a787f7cd04f5561dcdadff392c5af0bee"></a><!-- doxytag: member="boost::checks::check_isbn13" ref="a787f7cd04f5561dcdadff392c5af0bee" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_isbn13 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the isbn13_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN13_SIZE digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00089">89</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a36a3ea230792e9f9ba0c02ce1c46354c"></a><!-- doxytag: member="boost::checks::check_luhn" ref="a36a3ea230792e9f9ba0c02ce1c46354c" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_luhn </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the luhn_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00084">84</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2651a01fc5a7a3eec7381f18fcb04295"></a><!-- doxytag: member="boost::checks::check_luhn" ref="a2651a01fc5a7a3eec7381f18fcb04295" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_luhn </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the luhn_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00102">102</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae9e7b0798732cefb3c6d51a4cc68d09c"></a><!-- doxytag: member="boost::checks::check_mastercard" ref="ae9e7b0798732cefb3c6d51a4cc68d09c" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_mastercard </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mastercard_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly MASTERCARD_SIZE digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the two first digits (from the leftmost) don't match the mastercard pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="mastercard_8hpp_source.html#l00085">85</a> of file <a class="el" href="mastercard_8hpp_source.html">mastercard.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="afbc1a04be2d50c0caeb8f15237930513"></a><!-- doxytag: member="boost::checks::check_mod97_10" ref="afbc1a04be2d50c0caeb8f15237930513" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_mod97_10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mod97_10_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the two check digits are correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00154">154</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa32d98f0c9606a1d46786a57151c81ab"></a><!-- doxytag: member="boost::checks::check_mod97_10" ref="aa32d98f0c9606a1d46786a57151c81ab" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_mod97_10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mod97_10_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the two check digits are correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00172">172</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="acb7e8e0940822a9cb6836251c064e03f"></a><!-- doxytag: member="boost::checks::check_modulus11" ref="acb7e8e0940822a9cb6836251c064e03f" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_modulus11 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mod11_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00156">156</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a2d76774a0b153e9046cd18823cc12dd6"></a><!-- doxytag: member="boost::checks::check_modulus11" ref="a2d76774a0b153e9046cd18823cc12dd6" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_modulus11 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the mod11_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00174">174</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a3e9f9bfde34262ad3f4e69ddf2e1bbd4"></a><!-- doxytag: member="boost::checks::check_sequence" ref="a3e9f9bfde34262ad3f4e69ddf2e1bbd4" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_sequence </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigit. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the checkdigit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00099">99</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a574b80a0aafa204b1079de298dad8ea5"></a><!-- doxytag: member="boost::checks::check_sequence" ref="a574b80a0aafa204b1079de298dad8ea5" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_sequence </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigit. </td></tr>
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the checkdigit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00120">120</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a944d9977c2db906b76346bc76928f06d"></a><!-- doxytag: member="boost::checks::check_upca" ref="a944d9977c2db906b76346bc76928f06d" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_upca </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the upc_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly UPCA_SIZE digits.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00067">67</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="abe6ccc42ec484aac046ea80bfaad4ae4"></a><!-- doxytag: member="boost::checks::check_verhoeff" ref="abe6ccc42ec484aac046ea80bfaad4ae4" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_verhoeff </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the verhoeff_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00145">145</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a86e8991bc68fab9958a902b140bd05c6"></a><!-- doxytag: member="boost::checks::check_verhoeff" ref="a86e8991bc68fab9958a902b140bd05c6" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_verhoeff </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the verhoeff_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00163">163</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ab59d983a0e6f7df034570cdf7e14bdcb"></a><!-- doxytag: member="boost::checks::check_visa" ref="ab59d983a0e6f7df034570cdf7e14bdcb" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool boost::checks::check_visa </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Validate a sequence according to the visa_check_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly VISA_SIZE digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the first digit (from the leftmost) doesn't match the Visa pattern.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>True if the check digit is correct, false otherwise. </dd></dl>

<p>Definition at line <a class="el" href="visa_8hpp_source.html#l00083">83</a> of file <a class="el" href="visa_8hpp_source.html">visa.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a04b6c190de7e9bb7a99841a8ad996459"></a><!-- doxytag: member="boost::checks::compute_amex" ref="a04b6c190de7e9bb7a99841a8ad996459" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::amex_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_amex </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the amex_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly AMEX_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the two first digits (from the leftmost) don't match the amex pattern. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="amex_8hpp_source.html#l00105">105</a> of file <a class="el" href="amex_8hpp_source.html">amex.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="af2694703fb484efc186146542e4a7c53"></a><!-- doxytag: member="boost::checks::compute_checkdigit" ref="af2694703fb484efc186146542e4a7c53" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">algorithm::checkdigit&lt;check_range&gt;::type boost::checks::compute_checkdigit </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigit. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit of the type of a value in check_seq. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00140">140</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a58d8bcbe9cc7d264f4a2b09d49717a56"></a><!-- doxytag: member="boost::checks::compute_checkdigit" ref="a58d8bcbe9cc7d264f4a2b09d49717a56" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">algorithm::checkdigit&lt;check_range&gt;::type boost::checks::compute_checkdigit </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigit. </td></tr>
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit of the type of a value in check_seq. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00161">161</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a47d3a9835bc33566a01ca5614a13f1fe"></a><!-- doxytag: member="boost::checks::compute_checksum" ref="a47d3a9835bc33566a01ca5614a13f1fe" args="(iterator seq_begin, iterator seq_end)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , typename size_contract , typename iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int boost::checks::compute_checksum </td>
          <td>(</td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>seq_begin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">iterator&#160;</td>
          <td class="paramname"><em>seq_end</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Run through a sequence and calculate the checksum with the algorithm policy class. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>seq_begin and seq_end are valid iterators.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checksum. </td></tr>
    <tr><td class="paramname">size_contract</td><td>is a contract concerning the size of the sequence. </td></tr>
    <tr><td class="paramname">iterator</td><td>Must meet the InputIterator requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">seq_begin</td><td>Beginning of the sequence. </td></tr>
    <tr><td class="paramname">seq_end</td><td>Ending of the sequence.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">size_contract::exception_size_failure</td><td>If the terms of the contract are not respected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The checksum of the sequence calculated with algorithm. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00042">42</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a635c57c7b253fcadc1dfa5415d7647b1"></a><!-- doxytag: member="boost::checks::compute_checksum" ref="a635c57c7b253fcadc1dfa5415d7647b1" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , typename size_contract , typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">int boost::checks::compute_checksum </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Create iterators according to the algorithm::iterator policy. And call the iterator overload version of compute_checksum. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigit. </td></tr>
    <tr><td class="paramname">size_contract</td><td>is a contract concerning the size of the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">size_contract::exception_size_failure</td><td>If the terms of the contract are not respected.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The checksum of the sequence calculated with algorithm. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00077">77</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ac08dd90c2f9518ad9f9addb3863db98e"></a><!-- doxytag: member="boost::checks::compute_ean13" ref="ac08dd90c2f9518ad9f9addb3863db98e" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::ean_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_ean13 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the ean_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN13_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00094">94</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adb63ff3a11463aba48f55b5d96dfada1"></a><!-- doxytag: member="boost::checks::compute_ean8" ref="adb63ff3a11463aba48f55b5d96dfada1" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::ean_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_ean8 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the ean_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN8_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="ean_8hpp_source.html#l00131">131</a> of file <a class="el" href="ean_8hpp_source.html">ean.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a41519cb136ca0786262764baa7b4622f"></a><!-- doxytag: member="boost::checks::compute_isbn10" ref="a41519cb136ca0786262764baa7b4622f" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::mod11_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_isbn10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the mod11_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly ISBN10_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9,X]. </dd></dl>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00145">145</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5dd55ec9238d3d11527546f34d5ce2db"></a><!-- doxytag: member="boost::checks::compute_isbn13" ref="a5dd55ec9238d3d11527546f34d5ce2db" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::isbn13_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_isbn13 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the isbn13_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly EAN13_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="isbn_8hpp_source.html#l00108">108</a> of file <a class="el" href="isbn_8hpp_source.html">isbn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f86db1b7d82751de71288456d4edf0a"></a><!-- doxytag: member="boost::checks::compute_luhn" ref="a8f86db1b7d82751de71288456d4edf0a" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::luhn_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_luhn </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the luhn_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. (So the check digit is not included.) </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00122">122</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a72f611fe14c840774de011e0271eb4b0"></a><!-- doxytag: member="boost::checks::compute_luhn" ref="a72f611fe14c840774de011e0271eb4b0" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::luhn_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_luhn </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the luhn_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="luhn_8hpp_source.html#l00141">141</a> of file <a class="el" href="luhn_8hpp_source.html">luhn.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a0f8b86d5edf6cc569f494bb890c83dcc"></a><!-- doxytag: member="boost::checks::compute_mastercard" ref="a0f8b86d5edf6cc569f494bb890c83dcc" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::mastercard_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_mastercard </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the mastercard_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly MASTERCARD_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the two first digits (from the leftmost) don't match the mastercard pattern. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="mastercard_8hpp_source.html#l00105">105</a> of file <a class="el" href="mastercard_8hpp_source.html">mastercard.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="aa4c7db694c89fb4ba0a2b288776c66f3"></a><!-- doxytag: member="boost::checks::compute_mod97_10" ref="aa4c7db694c89fb4ba0a2b288776c66f3" args="(const check_range &amp;check_seq, checkdigits_iter mod97_checkdigits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range , typename checkdigits_iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">checkdigits_iter boost::checks::compute_mod97_10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">checkdigits_iter&#160;</td>
          <td class="paramname"><em>mod97_checkdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digits of a sequence according to the mod97_10_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).<br/>
 mod97_checkdigits should have enough reserved place to store the two check digits.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. (So the check digits are not included.) </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
    <tr><td class="paramname">checkdigits_iter</td><td>must meet the OutputIterator requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check. </td></tr>
    <tr><td class="paramname">mod97_checkdigits</td><td>is the OutputIterator in which the two check digits will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digits cannot be translated into the checkdigits_iter type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digits are stored into mod97_checkdigits. The range of these is [0..9][0..9]. </dd></dl>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00194">194</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a8f1e84d2acc21b23ebe972ca73a879b7"></a><!-- doxytag: member="boost::checks::compute_mod97_10" ref="a8f1e84d2acc21b23ebe972ca73a879b7" args="(const check_range &amp;check_seq, checkdigits_iter mod97_checkdigits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range , typename checkdigits_iter &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">checkdigits_iter boost::checks::compute_mod97_10 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">checkdigits_iter&#160;</td>
          <td class="paramname"><em>mod97_checkdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digits of a sequence according to the mod97_10_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 mod97_checkdigits should have enough reserved place to store the two check digits.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
    <tr><td class="paramname">checkdigits_iter</td><td>must meet the OutputIterator requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check. </td></tr>
    <tr><td class="paramname">mod97_checkdigits</td><td>is the OutputIterator in which the two check digits will be stored.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digits cannot be translated into the checkdigits_iter type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digits are stored into mod97_checkdigits. The range of these is [0..9][0..9]. </dd></dl>

<p>Definition at line <a class="el" href="modulus97_8hpp_source.html#l00215">215</a> of file <a class="el" href="modulus97_8hpp_source.html">modulus97.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a65a3b463188c57b0991eeb513e36817d"></a><!-- doxytag: member="boost::checks::compute_modulus11" ref="a65a3b463188c57b0991eeb513e36817d" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::mod11_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_modulus11 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the mod11_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. (So the check digit is not included.) </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9,X]. </dd></dl>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00194">194</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a9cb1939fed27705a86a2e609c49e35e5"></a><!-- doxytag: member="boost::checks::compute_modulus11" ref="a9cb1939fed27705a86a2e609c49e35e5" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::mod11_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_modulus11 </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the mod11_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9,X]. </dd></dl>

<p>Definition at line <a class="el" href="modulus11_8hpp_source.html#l00213">213</a> of file <a class="el" href="modulus11_8hpp_source.html">modulus11.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="adbf0f4f0f946d7c47fddd7553d9cd065"></a><!-- doxytag: member="boost::checks::compute_multicheckdigit" ref="adbf0f4f0f946d7c47fddd7553d9cd065" args="(const check_range &amp;check_seq, checkdigit_iterator checkdigits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , typename check_range , typename checkdigit_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">checkdigit_iterator boost::checks::compute_multicheckdigit </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">checkdigit_iterator&#160;</td>
          <td class="paramname"><em>checkdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the checkdigits of a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 checkdigits is a valid initialized iterator and have enough reserved place to store the check digits.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigits. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
    <tr><td class="paramname">checkdigit_iterator</td><td>must meet the OutputIterator requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check. </td></tr>
    <tr><td class="paramname">checkdigits</td><td>is the output iterator in which the check digits will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator initialized at one pass the end of checkdigits. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00184">184</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a5b6bdc6137cc4bc9b494138fa8b6127c"></a><!-- doxytag: member="boost::checks::compute_multicheckdigit" ref="a5b6bdc6137cc4bc9b494138fa8b6127c" args="(const check_range &amp;check_seq, checkdigit_iterator checkdigits)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename algorithm , size_t size_expected, typename check_range , typename checkdigit_iterator &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">checkdigit_iterator boost::checks::compute_multicheckdigit </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">checkdigit_iterator&#160;</td>
          <td class="paramname"><em>checkdigits</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the checkdigits of a sequence according to algorithm. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 checkdigits is a valid initialized iterator and have enough reserved place to store the check digits.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">algorithm</td><td>is a set of static method use to translate, filter and calculate or verify the checkdigits. </td></tr>
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
    <tr><td class="paramname">checkdigit_iterator</td><td>must meet the OutputIterator requirements. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check. </td></tr>
    <tr><td class="paramname">checkdigits</td><td>is the output iterator in which the check digits will be written.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>An iterator initialized at one pass the end of checkdigits. </dd></dl>

<p>Definition at line <a class="el" href="basic__checks_8hpp_source.html#l00207">207</a> of file <a class="el" href="basic__checks_8hpp_source.html">basic_checks.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="ae494e5fd020da1bacf88547eda843b81"></a><!-- doxytag: member="boost::checks::compute_upca" ref="ae494e5fd020da1bacf88547eda843b81" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::upc_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_upca </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the upc_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly UPCA_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="upc_8hpp_source.html#l00086">86</a> of file <a class="el" href="upc_8hpp_source.html">upc.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a069b69920cc6182e4bd0f1414cdc7747"></a><!-- doxytag: member="boost::checks::compute_verhoeff" ref="a069b69920cc6182e4bd0f1414cdc7747" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;size_t size_expected, typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::verhoeff_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_verhoeff </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the verhoeff_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.<br/>
 size_expected &gt; 0 (enforced by static assert).</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">size_expected</td><td>is the number of valid value expected in the sequence. (So the check digit is not included.) </td></tr>
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain size_expected valid values. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00183">183</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4bcb041b2939d1b52d223b9372b24536"></a><!-- doxytag: member="boost::checks::compute_verhoeff" ref="a4bcb041b2939d1b52d223b9372b24536" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::verhoeff_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_verhoeff </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the verhoeff_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq contains no valid value. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="verhoeff_8hpp_source.html#l00202">202</a> of file <a class="el" href="verhoeff_8hpp_source.html">verhoeff.hpp</a>.</p>

</div>
</div>
<a class="anchor" id="a4770ebdffc040e9cc9cb1fb6f1d75457"></a><!-- doxytag: member="boost::checks::compute_visa" ref="a4770ebdffc040e9cc9cb1fb6f1d75457" args="(const check_range &amp;check_seq)" -->
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename check_range &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">boost::checks::visa_compute_algorithm::checkdigit&lt; check_range &gt;::type boost::checks::compute_visa </td>
          <td>(</td>
          <td class="paramtype">const check_range &amp;&#160;</td>
          <td class="paramname"><em>check_seq</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Calculate the check digit of a sequence according to the visa_compute_algorithm type. </p>
<dl class="pre"><dt><b>Precondition:</b></dt><dd>check_seq is a valid range.</dd></dl>
<dl><dt><b>Template Parameters:</b></dt><dd>
  <table class="">
    <tr><td class="paramname">check_range</td><td>is a valid range type. </td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Parameters:</b></dt><dd>
  <table class="params">
    <tr><td class="paramname">check_seq</td><td>is the sequence of value to check.</td></tr>
  </table>
  </dd>
</dl>
<dl><dt><b>Exceptions:</b></dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if check_seq doesn't contain exactly VISA_SIZE_WITHOUT_CHECKDIGIT digits. </td></tr>
    <tr><td class="paramname">std::invalid_argument</td><td>if the first digit (from the leftmost) doESn't match the Visa pattern. </td></tr>
    <tr><td class="paramname"><a class="el" href="classboost_1_1checks_1_1translation__exception.html" title="This class provides support for translation failure. For example, sequence value into integer...">boost::checks::translation_exception</a></td><td>if the check digit cannot be translated into the checkdigit type.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>The check digit. The check digit is in the range [0..9]. </dd></dl>

<p>Definition at line <a class="el" href="visa_8hpp_source.html#l00103">103</a> of file <a class="el" href="visa_8hpp_source.html">visa.hpp</a>.</p>

</div>
</div>
</div>
<!-- custom Doxygen footer checks_doxygen_footer.html  -->-

<!-- Copyright 2011 Pierre Talbot. -->
<!-- Distributed under the Boost Software License, Version 1.0. -->
<!-- (See accompanying file LICENSE_1_0.txt or copy at          -->
<!-- http://www.boost.org/LICENSE_1_0.txt)                      -->

<hr size="1"/>
<table width="100%">
<tbody>
  <tr>
   <address style="text-align: left;">
     <p>Use, modification and distribution are subject to the Boost Software License, Version 1.0.<br/>
     (See accompanying file LICENSE_1_0.txt or copy at&nbsp;
     <a href="http://www.boost.org/LICENSE_1_0.txt"> http://www.boost.org/LICENSE_1_0.txt </a>)</p>
      <!-- Change copyright to YOUR name (and affiliation, if any) below:  -->
     <p>Copyright  2011 Pierre Talbot</p>
      <!-- 2011 becomes the current year, for example 2010, so claims copyright for a range of years, 2009 - 2010. -->
     <p>Doxygen Documentation generated by&nbsp;<a href="http://www.doxygen.org/index.html"> <img src="doxygen.png" alt="doxygen logo" align="middle" border="0"/> 1.7.5.1</a>, Revised at Tue Aug 23 2011 09:36:53</p>
  </address>
  </tr>
</tbody>
</table>
  <!-- You can also add a footer logo, taking care that the location of the footer.png is correct. -->
  <!-- <img src="../images/my_footer.png" alt="Boost Doxygen documentation footer.png" -->
  </body> <!-- <body> is in doxygen_header.html -->
</html><!-- <html>  is in doxygen_header.html -->


